test: #nom de la campagne
  graine: [0]
  constellation: [ tas_700 ] # name will be inflated from files chosen in this directory
  duree: [ 6 ] #en s
  pas: [2000] #en ms
  deteriorISL: [ { sel: topUtil10, errModel: "recvErrRate:0.01-interval:2000,4000ms"}, { sel: topUtil10, errModel: "recvErrRate:0.1-interval:2000,4000ms"} ] #, { sel: topUtil50, errModel: "gilbertElliottMdl-brstRate:0.01-brstSize:5-interval:15000,21000ms"}, { sel: topUtil50, errModel: "gilbertElliottMdl-brstRate:0.001-brstSize:5-interval:15000,21000ms"} ] #, { sel: topUtil10, errModel: "gilbertElliottMdl-brstRate:0.01-brstSize:5" } ] 
  nb-UEs-sol: [ 100 ]
  algo: [ "algorithm_penal_gsl" ]
  threads: [ 4 ]
  desactive-impairs: [ True ]
  debit-ifs: [ {'ue':2, 'sol':350, 'isl':60, 'satues':80, 'satgw':40}, {'ue':2, 'sol':200, 'isl':60, 'satues':80, 'satgw':80}   ] #Mb/s 
  logs-actifs: [ ['rx', 'drop', 'tx', 'coms' ] ] #('rx', 'tx', 'drop', 'qqd', 'coms', 'ping') # 'drop' callbacks are now effective with Traffic Control (just hope it wont crash) 
  estimDelai: [{"isl": 5.5, 'gsl': 40, 'extremite': 30 }] # délai dans la file d'attente
  # Théoriquement pour 1 flux TCP, le buffer doit avoir une capacité de RTT * débit_sortie_interface (thumb's rule). S'il y a beaucoup de flux, on peut diviser par sqrt(nb_flux)

  ##------------------
  # satellite_network_min_node_log: rx log only 1st station and satellites
  ##-----------------
  # examples of protocoles:
  # { 'nom':"udp", "extra_parameters":"expInterPacket" }
  # { 'nom':"udp"}
  # { 'nom': "tcp"}
  # { 'nom': 'udp', 'debut_ms': [1, 4],'duree_ms': 'min,max'
  protocoles:
    - test: {nom: tcp, debut_ms: [0, 100], duree_ms: 'max', ratio: 2, debit: 2}
    #- grp0: {nom: tcp, debut_ms: [0, 100], duree_ms: 'max', nb: 100, debit: 2 }
    #  grp1: {nom: tcp, debut_ms: [20000, 20100], duree_ms: 'max', nb: 100, debit: 2}
     # grp2: {nom: tcp, debut_ms: [20000, 20100], duree_ms: 'max', nb: 50, debit: 2}
     # grp3: {nom: tcp, debut_ms: [30000, 30100], duree_ms: 'max', nb: 50, debit: 2}
     # grp4: {nom: tcp, debut_ms: [40000, 40100], duree_ms: 'max', nb: 50, debit: 2}
     # grp5: {nom: tcp, debut_ms: [50000, 50100], duree_ms: 'max', nb: 50, debit: 2}
    #- test: {nom: tcp, debut_ms: [0, 100], duree_ms: 'max', ratio: 2, debit: 2 }
  # Dans UDP, le debit (par défaut le débit de la plus petite interface du premier ENDPOINT dans le fichier de constellation)
  # Le débits des commmodités UDP sont dérivés aléatoirement de celui-ci par 0.3*debit_reference+0.7*random_exponential(0.7*debit_reference)
  # Cela donne une distribution exponentielle décalée coupée de débit moyen 0.3*debit+debit*(1-exp(-0.7)) = 0.8*debit
  # in UDP, 'debit' is capped to debit_gsl
  # a tcp flow is defined by its size, which is calculated with debit and duree_ms
  # Débit UDP : max(udp_list_flow_size_proportion[i], 0.999*data_rate_GSL_megabit_per_s))
  # Dans TCP l'argument de débit sert à calculer la taille du fichier à envoyer
  # extra_parameters : string, thought as space-separated coefficients
  # pacingDR[double][unit or default to bit per sec] is an application level throttle, it only takes into account the payload
  srvTrafficControl:
    #- QueueDisc: "ns3::RRFQueueDisc" #ns3::ITbfQueueDisc, ns3::RRQueueDisc, etc..ns3::FifoQueueDisc par defaut 
    #  MaxSize: QueueSize 30p #type value
    #  ChildQueueDisc: "ns3::FifoQueueDisc"
    #  ChildRate: DataRate 2Mbps # in TbfQueueDisc #Child prefix is removed to set the attribute of the ChildQueueDisc
    - {"QueueDisc": "ns3::FqCoDelQueueDisc", "MaxSize": "QueueSize 100p", "Interval": "String 10ms", "Target": "String 100ms"} 
    - {}
    #- {"QueueDisc": "ns3::FqCoDelQueueDisc", "MaxSize": "QueueSize 60p", "Interval": "String 300ms", "Target": "String 200ms"} 

info-experience:
  campagnedir: "sauvegardes/{nom_campagne}"
  expedir: "svgde_{strdate}_{graine}_{pid}"
  sources: #select information that should be saved at the end of the experiment
    #directory: files or directory
    #"satgenpy_analysis/data/{constellation}_{isls}_{algo}/{pas}ms_for_{duree}s/": manual
    "satellite_networks_state/gen_data/{constellation}_{algo}_{pid}": ground_stations.txt
    "satellite_networks_state/gen_data/{constellation}_{algo}_{pid}/dynamic_state_{pas}ms_for_{duree}s": paths
    ns3_experiments/runs: "run_loaded_tm_pairing_for_{duree}s_with_{protocolesNom}_{algo}_{pid}"
    config: "temp{pid}.*" # ^(?!campagne).*$ #all but starting with campagne
  #currinfo: currlog #pour savoir où on en est, si lancé en arrière-plan

info-campagne:
  evals: #ces variables sont évaluées avant utilisation, et ajoutées au dictionnaire de campagne
    strdate: time.strftime('%Y-%m-%d-%H%M') #generate
    pid: 'os.getpid()'
  
  actions-inutiles-si:
    #inutile d'effectuer l'action si la cle changeante est
    "casse liens sat": [ "protocoles", "srvTrafficControl", "debit-ifs", "desactive-impairs", "estimDelai"]
    "routes": [ "protocoles", "srvTrafficControl", "debit-ifs", "desactive-impairs", "estimDelai"]

  mrpropre: #à la fin de la campagne
    "satellite_networks_state/gen_data" : ".*_{pid}"
    satellite_networks_state/input_data : "os_.*_{pid}.csv"
    ns3_experiments/runs: "run_loaded_tm_pairing_for_\\d+s_with_.*_.*_{pid}"
    config: "temp{pid}.*\\.yaml"


  actions: #[]
    - positionne #generate position files. Il vaut mieux éviter de lancer cette actions lorsqu'il y a plusieurs processus, l'accès au fichier est incertain. peut-être exécuter cette action seule au début, ou faire varier les fichiers générés, par ex en fonction du numero de processus
    - noeuds
    - commodites
    - routes
    - "casse liens sat"
    #- "analyse theorique" #not sure it still works. should be adapted or removed
    - simulation
  
  processus: 4 #number of experiments in parallel
  parallelise: True #False helps to debug